# 学び, 備忘録
## Day2
* MBR
  * OS読み込み用のプログラムが入っている補助記憶装置の先頭の部分。アドレス的には `0x7c00`。

* `times 0x01fe-($-$$) db 0` の `$-$$` は物理アドレスの先頭から現在のアドレスの差を計算している。
  * 例えば、現在の物理アドレスが0x7cE0だとすると(これが`$`)、`$-$$`は先頭(これが`$$`)アドレスとなる`0x7c00`との差を取る計算となり、差分は `0x00E0`。

* Makefile
  ```makefile
  <label>: <dependencies>
    <command>
  
  <dependencies>: 
    <command>
  
  # make <label> とすると、最初にdependenciesのラベルが実行されて、終了次第、依存元に戻る。
  ```

  example
  ```makefile
  img: 
	nasm helloos.asm

  run: img
	qemu-system-i386 -drive file=helloos,format=raw,if=floppy -boot a
  ```

* nasmのコンパイルオプション
  * -o : 指定したファイル名で出力する。
  * -l : listファイルを出力する。
    * アセンブラが生成したCPUが実行するバイナリコードと対応するアセンブラがリスト形式で表示される。

参考: https://www.mztn.org/lxasm64/amd02.html

## Day4
* VRAM
  * VRAMのメモリマップは0xa0000~0xaffff
  * ここに画面に表示したい色番号を指定していく。
* CLI 
  * ローカルだけど, CLear Interrupt flagの略語
  * 割り込みフラグを0にする(すなわち割り込みができないようにする)
* STI
  * 同様に SeT interrupt flagの略語
  * 割り込みフラグを1にする(すなわち割り込みできるようにする)
* EFLAGS
  * キャリーフラグや割り込みフラグなどが詰まった32bitのレジスタのこと。
  * 本編では割り込みフラグが1である状態を再現するためにEFLAGSを保存し、STIで保存したEFLAGSを使って割り込みフラグが1の状態を復元した。
* ディスプレイとVRAMについて
  * 0xa0000 + x + y * 320

## Day5
* struct BOOTINFO
  |メンバ|size|内容|
  |:---:|:---:|:---:|
  |cyls|char|読み出した位置を保存|
  |leds|char|LED状態を保存(for keyboard?)|
  |vmode|char|画面の状態|
  |reserve|char|?|
  |scrnx|short|画面の大きさ(width)|
  |scrny|short|画面の大きさ(height)|
  |vram|int|vramのメモリマップ(0x000a0000 0 0 0 \| 先頭から0x0ff8 0x0ff9 0x0ffa 0x0ffb)|

参考 http://bttb.s1.valueserver.jp/wordpress/blog/2017/12/17/makeos-5-2/

* -fno-pieオプションについて
自作sprintfをコンパイルするに当たって改めて調べたので書いてみる。
pieとはposition independent executablesの略で日本語だと位置独立実行形式のこと。
pie形式ではPIEバイナリとその依存関係はアプリケーションが実行されるたびに仮想メモリ内のランダムな場所にロードされる。
したがってリターン志向プログラミング(ROP?????)攻撃の実行を妨げる効果がある。

これ以上必要になったらここ読めばよさそう。 https://access.redhat.com/blogs/766093/posts/1975793

* GDT, IDT
  * GDTはセグメンテーションを参照テーブル。IDTは割り込みされた際にどのセグメントを実行するかを指定するテーブル。

## Day6
前日はGDT(global (segment) descriptor table), IDT(interrupt descriptor table)の初期化まで実装

* Makefileの一般規則、生成規則
  * 生成規則はラベルが具体的なもの。
  * 一般規則は生成規則が存在しないものに対して行う。
  ```Makefile
  %.o: %.c Makefile # % はラベル
    $(CC) $(CFLAG) $*.c -o $*.o # $*はターゲットのプレフィックス
  ```
* GDTR
  * 指定されたリミットと番地を格納するレジスタ
    * LGDT(asm)命令によって指定したアドレスから6byteのデータをGDTRに格納する。
* SEGMENT DESCRIPTOR
  * 64bit(8byteの構造体)　下位ビットから見て配置は以下の通り

  |メンバ|size|内容|
  |:---:|:---:|:---:|
  |limit_low|short|リミットの下位16bit|
  |base_low|short|セグメントの開始アドレス下位16bit|
  |base_mid|char|セグメントの開始アドレス中位8bit|
  |access right|char|アクセス権限8bit|
  |limit_high|4bit|リミットの上位4bit|
  |extend access right|4bit|拡張アクセス権限(GD00,と解釈される。Gはこのセグメントをページとして扱うか？Dは16bitor32bitモードかを決定する。)|
  |base_high|char|セグメントの開始アドレス上位8bit|
  
  * limit => 20bit, base address => 32bit, access right => 12bit が分割されてglobal descriptor tableに入っている。すごくわかりづらい。

* PIC
  * programmable interruput controllerの略。
  * 外部装置のアクセス場所を設定する。
  * IMR
    * IMRはPICのレジスタで割り込み目隠しレジスタという名前。
    * レジスタの容量は1byte(=8bit)でそれぞれのbitはIRQに対応し、1のときは信号を無視する(=割り込みを受け付けない)。
  * ICW
    * 初期化制御データ。それぞれ8bitのレジスタ。
    * ICW3はマスタースレーブ接続に関する設定。何番のIRQにスレーブがつながっているかを8bitで設定する。

## Day7
前回はSegment Descriptorの設定を行い、キーボードとマウス用の割り込みハンドラを設定した。
割り込み先は2つ目のセグメントでbootpack.hrbが存在する区画。

* IRQ受け付け完了命令
  * IRQからの割り込みを受け付けたことをPICに通知する命令。PICのPIC0_OCW2レジスタに0x60+IRQ番号を通知する。
  * これを行わないとPICはCPUが割り込みを処理してくれるまで待つことになり、新しい割り込みを行わなくなってしまう。
  * その後に0x0060から8bitデータを入力する。
    * io_in8(PORT_KEYDAT(0x60))

* 割り込み
  * Keyboard
    * Keyboardを押すと、PICがCPUに対して割り込みを入れる。
    * このとき割り込みフラグが1のときは割り込みでき、そうでないときは割り込みできない。
    * PICではIWQによってCPUに直接、呼び出す割り込みハンドラを実行させる。
    * 割り込みハンドラはPICに受信したことを報告し、KeyCodeを受け取ったら割り込みフラグを再び1にする。
    * 割り込みフラグを1にするのはKeycodeをPICから受け取る間だけでいい。
    * また、全てのPIC,基盤で同じ仕様かはわからないが1byteのCodeに対して1回割り込みが起こる。

* マウスの制御回路
  * マウスは起動時には有効になっていないので、キーボード制御回路を介して有効化する必要がある。

## Day8
昨日はキーボードからの入力を受け取り、画面に表示させる方法とマウスからの割り込みを受け取る方法を学んだ。

* マウスの解読
  * キーボード制御回路からマウスを有効にすると, 3byteずつマウスの情報が送られてくるようになる。
  * 最初は必ず0xfa, 次からマウスのボタン情報、x移動量、y移動量が送信されてくる。
  * 手順
    * (PIC) マウスからの割り込みが入る
    * (OS) 割り込みを処理することをPICに伝える
    * (OS) 0x0060からデータを受け取る。
    * (PIC) btn, x, yの順に1byteずつ、合計3byteデータが送信される。

* nasmheadについて
  * やってること
    CPUの設定やメモリマップの反映などを行う。CPUの設定変更中に割り込みが来ると混乱するのでPICからの割り込みは最初に止めている。
    * 1MB以上のメモリを使えるようにする(A20GATE信号線)
      * キーボード制御回路に0x6fを送信。
    * プロテクトモードへの変更
      * セグメントを使用できるようにする。
      * プロテクトされるのはOS用のセグメントやセグメント自体の設定。アプリケーションからそれらの情報を変更できないようにする。

## Day9
昨日はマウスから受け取った移動量からマウスカーソルを動かし、セグメントやCPUの設定を行っているnasmheadの解読を行った。
* chaceメモリ
  * 非常に高速なCPUの中に存在するメモリのこと。
  * 直接メモリに書き込む作業は非常に時間がかかるため、CPUはよく使う値(ループ変数など短時間で同じ番地の値を書き換えるようなもの)をキャッシュメモリに一時的に書きこむ。

* キャッシュメモリとメモリ容量チェック
  * BIOSに聞かず、自力でメモリ容量をチェックするにはどうすればよいか？
  * メモリ番地に適当なデータを書き込み、再びそのメモリ番地を読み、書き込む前と同じデータならばそこにはメモリが存在することがわかる。
  * ただし、この手法ではキャッシュメモリの存在が邪魔になる。
    * キャッシュメモリは番地とデータを対に保存する一時メモリのこと。
    * もし対象の番地にメモリが存在しなくてもキャッシュメモリには保存ができてしまい、同時に再読込することも可能になる。
  * そのため、メモリキャッシュ機能を一時的に無効にして上記の手法を用いる。(→ hairb06b bootpack.c memtest)

* メモリキャッシュ禁止
  * CR0レジスタを0にする

* スタックポインタと関数呼び出し
  |SP|格納されているもの|
  |:---:|:---:|
  |SP + 0|関数のシグネチャ|
  |SP + 4|引数(パディングは型のサイズによって変わるはず)|
  こんなかんじ？

## Day10
前日はメモリ容量の確認とメモリ管理手法を実装した。
ちなみにメモリ管理は
1. 空きスペースの開始アドレスと終了アドレスを指定。
2. アドレスから容量を計算。
3. FREEINFOに開始アドレスと計算した容量を保存。
4. MEMMANにFREEINFO情報を格納。

```c
struct FREEINFO { // 空き情報
	unsigned int addr, size;
};

struct MEMMAN { // メモリ管理
  int frees, maxfrees, lostsize, losts;
  struct FREEINFO free[MEMMAN_FREES];
};

// 0x00100000, 128byte Free
// 0x00101000, 518byte Free
// ...
// みたいな感じで空き情報が格納されている。
```

* 4kbyteずつ空き情報を格納
  * 前日のメモリ管理方法だと1byteずつデータを管理できるが、その分メモリのフリー要素が細切れになりやすい。
  * それを踏まえて4kbyteの倍数ずつメモリ容量を割り当てるようにする。

* 重ね合わせ処理
  * 下敷き(SHEET)という概念を導入。
    * 下敷きはsize, vx, vy(始点座標), 描画しない色, heightを持つ。
  * SHEETを管理するSHEET_CTRLを導入
    * heightを管理するsheets
      * heightが低い順番で描画される。
    * 下敷きの情報を管理するsheets0

* 描画処理
  * sheetのbufferを更新。
  * refreshを実行して、更新する範囲を高さの低い順番からvramを更新していく。

* マウスの描画処理(重ね合わせ対応版)
  * マウスを動かす。
  * 動かした場所の座標を取得。
  * Sheetを更新。heightの低い順番からvramに数値を設定していく。
    * もちろんマウスはheightが一番大きい。
  * マウス描画の番が来ると、bufferの値がvramに設定されるが、ここで描画しない値をvramに書き込まないことで下地の色がそのままに保たれるようになる。これによってマウスを動かしてもメニューバーの上などに重ね合わせることができる。

### HariboteOS 描画処理API
|関数|処理|
|:---:|:---:|
|sheet_init|Sheetのメモリを確保。vram, xsize, ysize, topなど構造体のフィールドを初期化|
|sheet_alloc|SheetManagerがsheets0を探索して使用できるsheetのポインタを返す|
|sheet_setbuf|表示するbufferのポインタとbufferのサイズ, 描画しない値の設定|
|sheet_updown|heightの変更|
|sheet_refresh|指定した大きさだけ描画し直す|
|sheet_refreshsub|指定した座標の範囲を描画し直す|
|sheet_slide|移動前の描画を削除。移動後の座標に指定したシートを描画する|
|sheet_free|シートを表示させないようにする。高さを全て変更する。|

## Day11
前日はマウスやウィンドウなどの重ね合わせを可能にするために、SHEETという概念を導入し、手前に出力したい順番にvramにデータを書き込む処理を実装した。
それを踏まえて今日はウィンドウを実装する。

* ウィンドウの実装
  * マウスカーソルと同様にウィンドウもSHEETで表現する。

* 表示処理を工夫する
  * これまでは1つのシートを更新 → 全てのシートをvramに書き出すという処理をしていた。
    * 変更されていないシートまで処理することになり無駄、かつ、常に奥にあるシートから描画することになるため手前に描画するマウスカーソルがちらちらしてしまう。
  * vramにどれだけデータを書き込んでも結局表示されるのは下敷きの1つなので、どの下敷きが表示されるかのマップを作っておく。
  * 更新時はmapを参照し、更新されたシートが書き込まれているvramだけ書き換える処理を行う。
    * 処理が軽くなる！！
    * 現在はマウスの移動時にmapを更新する...がウィンドウをマウスで動かすとか色々考えるともっと処理が必要になりそう...ではある。

## Day12
前日はウィンドウを実装した。SHEETの重ね合わせをリファクタし、高速化を行った。

* タイマ
  * 一定時間ごとに割り込みが来る機能(タイマ割り込み)。
    * タイマの使い方
      * HLT
      * 時計などなど
  * Programmable Interval Timer(PIT)
    * 何秒ごとに割り込みを起こすかを決められる装置。
      * IRQ0
      * IRQの設定
      ```
      割り込み周期の変更
      * AL = 0x34; OUT(0x43, AL);
      * AL = 割り込み周期の下位8bit; OUT(0x40, AL);
      * AL = 割り込み周期の上位8bit; OUT(0x40, AL);
      ```

* (復習)割り込みハンドラ
  * PICからの割り込みは, INT 0x?? の形式でCPUに直接命令が行える仕様になっている。
  * 0x??の位置に登録されている割り込みハンドラが実行される。

* (復習)I/Oポート
  * 制御機器と接続するためのポート
  * OUT命令を使ってアクセスできる外部機器とのインターフェース

## Day13 
Day12ではSHEET構造体のリファクタをして表示の処理を高速化した。
* FIFOの見直し
  * これまでのキューはput(&fifo, data)でデータをpushしていた。また、必要な分だけキューを用意し、データを使用していた。
  * 複数のキューを使うのは無駄なので、32byte入るキューを用意し、格納する値を対応するキーボードやマウスなりのデータを入れれば1個で済む。
* タイマの高速化
  * 連結リストを使う。タイマはタイムアウトが近い順番で並んでいるが、その間に入れる処理にポインタの張替えを行うことで少しだが、処理速度が改善される。

## Day14
前日は連結リストを使ったタイマの高速化を行った。

* VESA(VESA BIOS Extensions)
  * VESAによって標準化されたソフトウェア側からビデオカードの解像度や、指揮数を設定するインターフェース(from Wikipedia)
  * グラフィックスが発展していた当時、ビデオカードの仕様が会社ごとに異なっていたため、ある程度標準化したインターフェースを与えられるように制定された。INT 0x10で呼び出す。

* VESAのファンクション
  * 基本的に[ここ](http://oswiki.osask.jp/?VESA)を参照。
  * qemuで実装時、少し詰まったのが画像モードを1024*768にしたときのVRAMのポインタ
    * 30日OS本と実装時のアドレスは違っていた(0xe0000000 -> 0xfd000000)
  * アセンブラでレジスタに引数を代入し、INT 0x10でcall。
    * 前述のVRAMのアドレスは画面モード情報から取得できる。(\[ES:DI+0x28\]から4byte)

## Day15
* マルチタスク
  * 1つのCPUで複数のタスクを同時に実行しているように見せかける処理のこと。
    * 音楽を聞きながらブラウザを開いて動画を見たりコードを買いたり...全部マルチタスクがないとできない(現在のCPUはマルチコアだけども)
  * 0.01 ~ 0.03秒の間でCPUが実行するタスクを切り替えることでマルチタスクの処理を実現している。
    * この実行時間のことをタイムスライスと言ったりする

* コンテキストスイッチ
  * タスクの切り替え処理のこと。
    1. TRレジスタに実行するタスクを書き出す。
    2. JMP FAR命令で実行したいTSS(Task Status Segment)が書き込まれているセグメントを指定する。
    3. CPUはスイッチする前のレジスタの内容をスイッチ前のタスクを記録するセグメントに書き出す。
    4. TSSを読み出す。
    5. EIPレジスタに書き込まれたメモリアドレスから命令を読み出してCPUの処理を再開する。

* EIPレジスタ
  * 次に実行する命令がメモリのどの番地にあるかをCPUが記憶するためのレジスタ。program counter。
  * CPUが命令を1つ読み出すと、eipは更新されて次の番地を指すようになる。

* ESPレジスタ
  * スタックポインタのこと。CPUの一時記憶領域として使われる領域だが、ESPレジスタには次に書き込める場所のメモリ番地が入る。

* **本物**のタスクスイッチ
  * タイマ割り込みのハンドラでスイッチさせる。
  * こうすることでタスクの状態関係なく必ずスイッチさせられる。
    * 一方でハンドラ内でタスクスイッチさせると、タスクスイッチの最中に割り込みフラグが1になる場合などに対処できずバグる。

## Day16
マルチタスク続き。

* タスクの優先度・処理順番
  Day15のタスクスケジューラはラウンドロビンであり、全てのタスクに同じ処理時間を割り当てていた。
  タスクに優先度を与えることで頻繁に使用するタスクには多くの処理時間を割り当てられるようになる。

* タスクのスリープ
  ほとんど処理がされないタスクに割り当てられている処理時間は無駄である。
  ここではタスクスケジューラのタスクキューからタスクを取り除くことで実現する。
  
* タスクの復帰
  タスクに対してイベントが発生するとタスクは再びタスクキューに投入される。
  HariboteOSでは入出力の割り込みで割り込みハンドラがキューにデータを投入するとイベントが発生してタスクが復帰する。

## Day17
コンソールを作る。

* コンソール
  * Windowと同じようにBoxを組み合わせてコンソールを作る。
![Screenshot from 2020-04-16 20-30-09](https://user-images.githubusercontent.com/37650565/79451209-21f1eb00-8021-11ea-8b7a-540b228666e6.png)

## Day18
非アクティブウィンドウのカーソル点滅の停止と一部ターミナルコマンドの実装

* 非アクティブウィンドウのカーソル制御
  * キーボードやマウス、タイマーからのメッセージはタスクAが持つキューを介して取得できる。
  * そのため、タスクAのウィンドウが非アクティブ時にはタスクBに予め決めたメッセージをプッシュして、タスクBで受け取れば良い。
  * HariboteOSではタスクBがアクティブ時にはintの1をキューにpushしている

* エンターキー 
  * コンソールではエンターキーを押すと改行される。
  * 改行時の処理
    1. まだコンソールに余白があるとき
      * カーソルの表示位置(y座標)を文字分下げる。
    2. コンソールに余白がないとき(スクロール)
      * 一番上の行以外を1行分上にずらす。
      * 一番したの行は黒(背景色)で塗りつぶして、カーソルを表示する。

* memコマンド
  * メモリの空き容量を表示する。

* clearコマンド
  * エンターキーのスクロール処理を利用して、表示部分を背景色に塗りつぶす。

* lsコマンド
  * FAT形式で書き込まれているファイル情報を読み取って表示する。
  * 今のubuntuのファイルシステムってext4って言うんですね。

## Day19
typeコマンドの実装, tab文字, enterの解釈, FATの理解, アプリケーションの実行

* typeコマンドの実装
  * type \*.\*で対象のファイルを表示する(cat command).
  * 0x00100000 ~ 0x00267fffに記録されているファイル名とクラスタ番号から対象のファイルの内容が書かれている番地を割り出す。
    * ディスクイメージ内での番地 = クラスタ番号 * 512(1セクタの大きさ) + 0x003e00(ファイルの開始地点)
  * ここまでわかったら先頭からデータを読み出してコンソールにひたすら書いていく。
  * enterとtab文字は別に解釈してコンソールに出力

* FAT(file allocation table)
  * セクタ2からセクタ9までの8セクタ分あるファイル配置表
  * 1セクタの大きさは最大でも512byteなので、それ以上の大きさのファイルを保存しようとすると2つ以上のセクタを使わなければならない。
  * FATにはクラスタ番号に対応した場所に次のファイル内容が書いてあるクラスタ番号が書いてある。
    * クラスタ = セクタでいいはず...
    * セクタの総数は2880個なのでこの総数を表現するには12bitあれば良い。そのためFATにもそれぞれのクラスタのアドレスに12bitずつ次のクラスタ番号が書いてある。普通に先頭から12bitずつ書けばいいと思うんだけどよくわからない圧縮がしてある。なんでだろ

* アプリケーションの実行
  * ディスクイメージを作るときに一緒に実行ファイルをロードしておく。
  * OS起動中にアプリケーションを実行するには、前述の方法ファイルの中身を読み出す。
  * その後、セグメントに読み出したアプリケーションの内容を記述し、farjmpでタスクをスイッチ。
